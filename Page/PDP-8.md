's National Museum of American History in Washington, D.C.. This example is from the first generation of PDP-8s, built with discrete transistors and later known as the _Straight 8_.]] drive at the top]]

The PDP-8 is a 12-bit minicomputer that was produced by Digital Equipment Corporation (DEC). It was the first commercially successful minicomputer, with over 50,000 examples being sold over the model's lifetime. Its basic design follows the pioneering LINC but has a smaller instruction set, which is an expanded version of the PDP-5 instruction set.[1] Similar machines from DEC are the PDP-12 which is a modernized version of the PDP-8 and LINC concepts, and the PDP-14 industrial controller system.

The earliest PDP-8 model, informally known as a "Straight-8", was introduced on 22 March 1965 priced at $18,500[2] (). It used diode–transistor logic packaged on flip chip cards in a machine about the size of a small household refrigerator.[3] It was the first computer to be sold for under $20,000,[4] making it the best-selling computer in history at that time.[5][6] The Straight-8 was supplanted in 1966 by the PDP-8/S, which was available in desktop and rack-mount models. Using a one-bit serial arithmetic logic unit (ALU) allowed the PDP-8/S to be smaller and less expensive, although slower than the original PDP-8. A basic 8/S sold for under $10,000, the first machine to reach that milestone.[7][8]

Later systems (the PDP-8/I and /L, the PDP-8/E, /F, and /M, and the PDP-8/A) returned to a faster, fully parallel implementation but use much less costly transistor–transistor logic (TTL) MSI logic. Most surviving PDP-8s are from this era. The PDP-8/E is common, and well-regarded because many types of I/O devices were available for it. The last commercial PDP-8 models introduced in 1979 are called "CMOS-8s", based on CMOS microprocessors. They were not priced competitively, and the offering failed. Intersil sold the integrated circuits commercially through 1982 as the Intersil 6100 family. By virtue of their CMOS technology they had low power requirements and were used in some embedded military systems.

The chief engineer who designed the initial version of the PDP-8 was Edson de Castro, who later founded Data General.[9]


Architectural significance

The PDP-8 combines low cost,[10] simplicity, expandability, and careful engineering for value. The greatest historical significance was that the PDP-8's low cost and high volume made a computer available to many new customers for many new uses. Its continuing significance is as a historical example of value-engineered[11] computer design.

The low complexity brought other costs. It made programming cumbersome, as is seen in the examples in this article and from the discussion of "pages" and "fields". Much of one's code performed the required mechanics, as opposed to setting out the algorithm. For example, subtracting a number involves computing its two's complement then adding it; writing a conditional jump involves writing a conditional skip around the jump, the skip coding the condition negative to the one desired. Some ambitious programming projects failed to fit in memory or developed design defects that could not be solved. For example, as noted below, inadvertent recursion of a subroutine produces defects that are difficult to trace to the subroutine in question.

As design advances reduced the costs of logic and memory, the programmer's time became relatively more important.[12] Subsequent computer designs emphasized ease of programming, typically using larger and more intuitive instruction sets.[13]

Eventually, most machine code was generated by compilers and report generators.[14] The reduced instruction set computer returned full-circle to the PDP-8's emphasis on a simple instruction set and achieving multiple actions in a single instruction cycle, in order to maximize execution speed, although the newer computers have much longer instruction words.


Description

+-------------------+
| _PDP-8 registers_ |
+-------------------+
| [TABLE]           |
+-------------------+

The PDP-8 used ideas from several 12-bit predecessors, most notably the LINC designed by W.A. Clark and C.E. Molnar, who were inspired by Seymour Cray's CDC 160 minicomputer.[15][16] The PDP-8 uses 12 bits for its word size and arithmetic (on unsigned integers from 0 to 4095 or signed integers from -2048 to +2047). However, software can do multiple-precision arithmetic. An interpreter was available for floating point operations, for example, that used a 36-bit floating point representation with a two-word (24-bit) mantissa and one-word exponent.[17] Subject to speed and memory limitations, the PDP-8 can perform calculations similar to more expensive contemporary electronic computers, such as the IBM 1130 and various models of the IBM System/360, while being easier to interface with external devices.

The memory address space is also 12 bits, so the PDP-8's basic configuration has a main memory of 4,096 (2¹²) twelve-bit words. An optional memory-expansion unit can switch banks of memories using an IOT instruction. The memory is magnetic-core memory with a cycle time of 1.5 microseconds (0.667 MHz), so that a typical two-cycle (Fetch, Execute) memory-reference instruction runs at a speed of 0.333 MIPS. The 1974 Pocket Reference Card for the PDP-8/E gives a basic instruction time of 1.2 microseconds, or 2.6 microseconds for instructions that reference memory.

The PDP-8 was designed in part to handle contemporary telecommunications and text. Six-bit character codes were in widespread use at the time, and the PDP-8's twelve-bit words can efficiently store two such characters. In addition, a six-bit teleprinter code called the teletypesetting or TTS code was in widespread use by the news wire services, and an early application for the PDP-8 was typesetting using this code.[18] Later, 7-bit ASCII and 8-bit UTF-8 character codes were developed in part as a response to the limitations of five- and six-bit character codes.

PDP-8 instructions have a 3-bit opcode, so there are only eight instructions. The assembler provides more instruction mnemonics to a programmer by translating I/O and operate-mode instructions to combinations of the op-codes and instruction fields. It also has only three programmer-visible registers: A 12-bit accumulator (AC), a program counter (PC), and a carry flag called the "link register" (L).

For input and output, the PDP-8 has a single interrupt shared by all devices, an I/O bus accessed by I/O instructions and a direct memory access (DMA) channel. The programmed I/O bus typically runs low to medium-speed peripherals, such as printers, teletypes, paper tape punches and readers, while DMA is used for cathode ray tube screens with a light pen, analog-to-digital converters, digital-to-analog converters, tape drives, and disk drives.

To save money, the design used inexpensive main memory for many purposes that are served by more expensive flip-flop registers in other computers,[19] such as auxiliary counters and subroutine linkage.

Basic models use software to do multiplication and division. For faster math, the Extended Arithmetic Element (EAE) provides multiply and divide instructions with an additional register, the Multiplier/Quotient (MQ) register. The EAE was an option on the original PDP-8,[20] the 8/I,[21] and the 8/E, but it is an integral part of the Intersil 6100 microprocessor.

The PDP-8 is optimized for simplicity of design. Compared to more complex machines, unnecessary features were removed and logic is shared when possible. Instructions use autoincrement, autoclear, and indirect access to increase the software's speed, reduce memory use, and substitute inexpensive memory for expensive registers.

The electronics of a basic PDP-8 CPU has only four 12-bit registers: the accumulator, program counter, memory-buffer register, and memory-address register. To save money, these served multiple purposes at different points in the operating cycle. For example, the memory buffer register provides arithmetic operands, is part of the instruction register, and stores data to rewrite the core memory. (This restores the core data destroyed by the read.)

Because of their simplicity, early PDP-8 models were less expensive than most other commercially available computers. However, they used costly production methods often used for prototypes. They used thousands of very small, standardized logic-modules, with gold connectors, integrated by a costly, complex wire-wrapped backplane in a large cabinet.

In the later 8/S model, two different logic voltages increased the fan-out of the inexpensive diode–transistor logic.[22] The 8/S also reduced the number of logic gates by using a serial, single-bit-wide data path to do arithmetic. The CPU of the PDP-8/S has only about 519 logic gates. In comparison, small microcontrollers (as of 2008) usually have 15,000 or more. The reductions in the electronics permitted a much smaller case, about the size of a bread-box.

The even later PDP-8/E is a larger, more capable computer, but further reengineered for better value. It employs faster transistor–transistor logic, in integrated circuits. The core memory was redesigned. It allows expansion with less expense because it uses the OMNIBUS in place of the wire-wrapped backplane on earlier models. (A personal account of the development of the PDP-8/E can be read on the Engineering and Technology History Wiki.[23])


Versions of the PDP-8

The total sales figure for the PDP-8 family has been estimated at over 300,000 machines. The following models were manufactured:

-   PDP-8 - weight: [24]
-   LINC-8
-   PDP-8/S - weight: [25]
-   PDP-8/I - 1968,[26] weight: [27]
-   PDP-8/L - 1968,[28] weight: [29]
-   PDP-12
-   PDP-8/E
-   PDP-8/F
-   PDP-8/M
-   PDP-8/A
-   Intersil 6100 single-chip PDP-8-compatible microprocessor (used in the VT78)
-   Harris 6120 CMOS single-chip PDP-8-compatible microprocessor (used in the DECmate word processors)

Latter-day implementations

The PDP-8 is readily emulated, as its instruction set is much simpler than modern architectures. Enthusiasts have created entire PDP-8s using single FPGA devices.

Several software simulations of a PDP-8 are available on the Internet, as well as open-source hardware re-implementations.[30][31] The best of these correctly execute DEC's operating systems and diagnostic software. The software simulations often simulate late-model PDP-8s with all possible peripherals. Even these use only a tiny fraction of the capacity of a modern personal computer.


Input/output

The I/O systems underwent huge changes during the PDP-8 era. Early PDP-8 models use a front panel interface, a paper-tape reader and a teletype printer with an optional paper-tape punch. Over time, I/O systems such as magnetic tape, RS-232 and current loop dumb terminals, punched card readers, and fixed-head disks were added. Toward the end of the PDP-8 era, floppy disks and moving-head cartridge disk drives were popular I/O devices. Modern enthusiasts have created standard PC style IDE hard disk adapters for real and simulated PDP-8 computers.

Several types of I/O are supported:

-   In-backplane dedicated slots for I/O controllers
-   A "Negative" I/O bus (using negative voltage signalling)
-   A "Positive" I/O bus (the same architecture using TTL signalling)
-   The Omnibus (a backplane of undedicated system bus slots) introduced in the PDP-8/E. (Details are described in the referenced IEEE article listed below.)

A simplified, inexpensive form of DMA called "three-cycle data break" is supported; this requires the assistance of the processor. The "data break" method moves some of common logic needed to implement DMA I/O from each I/O device into one common copy of the logic within the processor. "Data break" places the processor in charge of maintaining the DMA address and word count registers. In three successive memory cycles, the processor updates the word count, updates the transfer address, and stores or retrieves the actual I/O data word.

One-cycle data break effectively triples the DMA transfer rate because only the target data needed to be transferred to and from the core memory. However, the I/O devices need more electronic logic to manage their own word count and transfer address registers. By the time the PDP-8/E was introduced, electronic logic had become less expensive and "one-cycle data break" became more popular.


Programming facilities

Early PDP-8 systems did not have an operating system, just a front panel with run and halt switches. Software development systems for the PDP-8 series began with the most basic front-panel entry of raw binary machine code (booting entry).

In the middle era, various paper tape "operating systems" were developed. Many utility programs became available on paper tape. PAL-8 assembly language source code was often stored on paper tape, read into memory, and saved to paper tape. PAL assembled from paper tape into memory. Paper tape versions of a number of programming languages were available, including DEC's FOCAL interpreter[32] and a 4K FORTRAN compiler and runtime.

Toward the end of the PDP-8 era, operating systems such as OS/8 and COS-310 allowed a traditional line mode editor and command-line compiler development system using languages such as PAL-III assembly language, FORTRAN, BASIC, and DIBOL.

Fairly modern and advanced real-time operating system (RTOS) and preemptive multitasking multi-user systems were available: a real-time system (RTS-8) was available as were multiuser commercial systems (COS-300 and COS-310) and a dedicated single-user word-processing system (WPS-8).

A time-sharing system, TSS-8, was also available. TSS-8 allows multiple users to log into the system via 110-baud terminals, and edit, compile and debug programs. Languages include a special version of BASIC, a FORTRAN subset similar to FORTRAN-1 (no user-written subroutines or functions), an ALGOL subset, FOCAL, and an assembler called PAL-D.

A fair amount of user-donated software for the PDP-8 was available from DECUS, the Digital Equipment Corporation User Society, and often came with full source listings and documentation.


Instruction set

The three high-order bits of the 12-bit instruction word (labelled bits 0 through 2) are the operation code. For the six operations that refer to memory, bits 5 through 11 provide a 7-bit address. Bit 4, if set, says to complete the address using the 5 high-order bits of the program counter (PC) register, meaning that the addressed location was within the same 128 words as the instruction. If bit 4 is clear, zeroes are used, so the addressed location is within the first 128 words of memory. Bit 3 specifies indirection; if set, the address obtained as described so far points to a 12-bit value in memory that gives the actual effective address for the instruction; this allows operands to be anywhere in memory at the expense of an additional word. The JMP instruction does not operate on a memory word, except if indirection is specified, but has the same bit fields.

  ----------- --- --- -------- --- --- -- -- -- -- -- ----
  0               2   3        4   5                  11
  Operation   I   Z   Offset
  ----------- --- --- -------- --- --- -- -- -- -- -- ----

Memory pages

This use of the instruction word divides the 4,096-word memory into 128-word pages; bit 4 of the instruction selects either the current page or page 0 (addresses 0000–0177 in octal). Memory in page 0 is at a premium, since variables placed here can be addressed directly from any page. (Moreover, address 0000 is where any interrupt service routine must start, and addresses 0010–0017 have the special property of auto-incrementing preceding any indirect reference through them.)

The standard assembler places constant values for arithmetic in the current page. Likewise, cross-page jumps and subroutine calls use an indirect address in the current page.

It was important to write routines to fit within 128-word pages, or to arrange routines to minimize page transitions, as references and jumps outside the current page require an extra word. Consequently, much time was spent cleverly conserving one or several words. Programmers deliberately placed code at the end of a page to achieve a free transition to the next page as PC was incremented.

Basic instructions

    000 – AND – AND the memory operand with AC.
    001 – TAD – Two's complement ADd the memory operand to <L,AC> (a _12 bit_ signed value (AC) w. carry in L).
    010 – ISZ – Increment the memory operand and Skip next instruction if result is Zero.
    011 – DCA – Deposit AC into the memory operand and Clear AC.
    100 – JMS – JuMp to Subroutine (storing return address in first word of subroutine!).
    101 – JMP – JuMP.
    110 – IOT – Input/Output Transfer (see below).
    111 – OPR – microcoded OPeRations (see below).

IOT (Input-Output Transfer) instructions

The PDP-8 processor defined few of the IOT instructions, but simply provided a framework. Most IOT instructions were defined by the individual I/O devices.

  ------- -------- ---------- --- -- -- -- -- --- --- -- ----
  0                2          3               8   9      11
  6=IOT   Device   Function
  ------- -------- ---------- --- -- -- -- -- --- --- -- ----

Device

Bits 3 through 8 of an IOT instruction select an I/O device. Some of these device addresses are standardized by convention:

-   00 is handled by the processor and not sent to any I/O device (see below).
-   01 is usually the high-speed paper tape reader.
-   02 is the high-speed paper tape punch.
-   03 is the console keyboard (and any associated low-speed paper tape reader).
-   04 is the console printer (and any associated low-speed paper tape punch).

Instructions for device 0 affect the processor as a whole. For example, ION (6001) enables interrupt processing, and IOFF (6002) disables it.

Function

Bits 9 through 11 of an IOT instruction select the function(s) the device performs. Simple devices (such as the paper tape reader and punch and the console keyboard and printer) use the bits in standard ways:

-   Bit 11 causes the processor to skip the next instruction if the I/O device is ready.
-   Bit 10 clears AC.
-   Bit 9 moves a word between AC and the device, initiates another I/O transfer, and clears the device's "ready" flag.

These operations take place in a well-defined order that gives useful results if more than one bit is set.

More complicated devices, such as disk drives, use these 3 bits in device-specific fashions. Typically, a device decodes the 3 bits to give 8 possible function codes.

OPR (OPeRate)

Many operations are achieved using OPR, including most of the conditionals. OPR does not address a memory location; conditional execution is achieved by conditionally skipping one instruction, which is typically a JMP.

The OPR instruction was said to be "microcoded." This did not mean what the word means today (that a lower-level program fetched and interpreted the OPR instruction), but meant that each bit of the instruction word specifies a certain action, and the programmer could achieve several actions in a single instruction cycle by setting multiple bits. In use, a programmer can write several instruction mnemonics alongside one another, and the assembler combines them with OR to devise the actual instruction word. Many I/O devices support "microcoded" IOT instructions.

Microcoded actions take place in a well-defined sequence designed to maximize the utility of many combinations.

The OPR instructions come in Groups. Bits 3, 8 and 11 identify the Group of an OPR instruction, so it is impossible to combine the microcoded actions from different groups.

Group 1

            00 01 02 03 04 05 06 07 08 09 10 11
            ___________________________________
           | 1| 1| 1| 0|  |  |  |  |  |  |  |  |
           |__|__|__|__|__|__|__|__|__|__|__|__|
                       |CLA   CMA   RAR   BSW
                           CLL   CML   RAL   IAC

        Execution order  1  1  2  2  4  4  4  3

    7200 – CLA – Clear Accumulator
    7100 – CLL – Clear the L Bit
    7040 – CMA – Ones Complement Accumulator
    7020 – CML – Complement L Bit
    7001 – IAC – Increment <L,AC>
    7010 – RAR – Rotate <L,AC> Right
    7004 – RAL – Rotate <L,AC> Left
    7012 – RTR – Rotate <L,AC> Right Twice
    7006 – RTL – Rotate <L,AC> Left Twice
    7002 – BSW – Byte Swap 6-bit "bytes" (PDP 8/e and up)

In most cases, the operations are sequenced so that they can be combined in the most useful ways. For example, combining CLA (CLear Accumulator), CLL (CLear Link), and IAC (Increment ACcumulator) first clears the AC and Link, then increments the accumulator, leaving it set to 1. Adding RAL to the mix (so CLA CLL IAC RAL) causes the accumulator to be cleared, incremented, then rotated left, leaving it set to 2. In this way, small integer constants were placed in the accumulator with a single instruction.

The combination CMA IAC, which the assembler lets you abbreviate as CIA, produces the arithmetic inverse of AC: the twos-complement negation. Since there is no subtraction instruction, only the twos-complement add (TAD), computing the difference of two operands, requires first negating the subtrahend.

A Group 1 OPR instruction that has none of the microprogrammed bits set performs no action. The programmer can write NOP (No Operation) to assemble such an instruction.

Group 2, Or Group

             00 01 02 03 04 05 06 07 08 09 10 11
            ___________________________________
           | 1| 1| 1| 1|  |  |  |  | 0|  |  | 0|
           |__|__|__|__|__|__|__|__|__|__|__|__|
                       |CLA   SZA      OSR
                           SMA   SNL      HLT

                         2  1  1  1     3  3

    7600 – CLA – Clear AC
    7500 – SMA – Skip on AC < 0 (or group)
    7440 – SZA – Skip on AC = 0 (or group)
    7420 – SNL – Skip on L ≠ 0 (or group)
    7404 – OSR – logically 'or' front-panel switches with AC
    7402 – HLT – Halt

When bit 8 is clear, a skip is performed if any of the specified conditions are true. For example, "SMA SZA", opcode 7540, skips if AC ≤ 0.

A Group 2 OPR instruction that has none of the microprogrammed bits set is another No-Op instruction.

Group 2, And Group

             00 01 02 03 04 05 06 07 08 09 10 11
            ___________________________________
           | 1| 1| 1| 1|  |  |  |  | 1|  |  | 0|
           |__|__|__|__|__|__|__|__|__|__|__|__|
                       |CLA   SNA      OSR
                           SPA   SZL      HLT

                         2  1  1  1     3  2

    7410 – SKP – Skip Unconditionally
    7610 – CLA – Clear AC
    7510 – SPA – Skip on AC ≥ 0 (and group)
    7450 – SNA – Skip on AC ≠ 0 (and group)
    7430 – SZL – Skip on L = 0 (and group)

When bit 8 is set, the Group 2, Or skip condition is inverted, via De Morgan's laws: the skip is _not_ performed if any of the group 2, Or conditions are true, meaning that _all_ of the specified skip conditions must be true. For example, "SPA SNA", opcode 7550, skips if AC > 0. If none of bits 5–7 are set, then the skip is unconditional.

Group 3

Unused bit combinations of OPR are defined as a third Group of microprogrammed actions mostly affecting the MQ (Multiplier/Quotient) register.

            00 01 02 03 04 05 06 07 08 09 10 11
            ___________________________________
           | 1| 1| 1| 1|  |  |  |  |  |  |  | 1|
           |__|__|__|__|__|__|__|__|__|__|__|__|
                       |CLA   SCA   _    _/
                       |   MQA   MQL  CODE

                         1* 2  2  2     3

    7601 – CLA – Clear AC
    7501 – MQA – Multiplier Quotient with AC (logical or MQ into AC)
    7441 – SCA – Step counter load into AC
    7421 – MQL – Multiplier Quotient Load (Transfer AC to MQ, clear AC)
    7621 – CAM – CLA + MQL clears both AC and MQ.

Typically CLA and MQA were combined to transfer MQ into AC. Another useful combination is MQA and MQL, to exchange the two registers.

Three bits specified a multiply/divide instruction to perform:

    7401 – No operation
    7403 – SCL – Step Counter Load (immediate word follows, PDP-8/I and up)
    7405 – MUY – Multiply
    7407 – DVI – Divide
    7411 – NMI – Normalize
    7413 – SHL – Shift left (immediate word follows)
    7415 – ASR – Arithmetic shift right
    7417 – LSR – Logical shift right


Memory control

A 12-bit word can have 4,096 different values, and this is the maximum number of words the original PDP-8 can address indirectly through a word pointer. As programs became more complex and the price of memory fell, it became desirable to expand this limit.

To maintain compatibility with pre-existing programs, new hardware outside the original design added high-order bits to the effective addresses generated by the program. The Memory Extension Controller expands the addressable memory by a factor of 8, to a total of 32,768 words. This expansion was thought sufficient because, with core memory then costing about 50 cents a word, a full 32K of memory would equal the cost of the CPU.

Each 4K of memory is called a field. The Memory Extension Controller contains two three-bit registers: the DF (Data Field) and the IF (Instruction Field). These registers specify a field for each memory reference of the CPU, allowing a total of 15 bits of address. The IF register specifies the field for instruction fetches and direct memory references; the DF register specifies the field for indirect data accesses. A program running in one field can reference data in the same field by direct addressing, and reference data in another field by indirect addressing.

A set of I/O instructions in the range 6200 through 6277 is handled by the Memory Extension Controller and give access to the DF and IF registers. The 62X1 instruction (CDF, Change Data Field) set the data field to X. Similarly 62X2 (CIF) set the instruction field, and 62X3 set both. Pre-existing programs would never execute CIF or CDF; the DF and IF registers would both point to the same field, a single field to which these programs were limited. The effect of the CIF instruction was deferred to coincide with the next JMP or JMS instruction, so that executing CIF would not cause a jump.

It was more complicated for multiple-field programs to deal with field boundaries and the DF and IF registers than it would have been if they could simply generate 15-bit addresses, but the design provided backward compatibility and is consistent with the 12-bit architecture used throughout the PDP-8. Compare the later Intel 8086, whose 16-bit memory addresses are expanded to 20 bits by combining them with the contents of a specified or implied segment register.

The extended memory scheme let existing programs handle increased memory with minimal changes. For example, 4K FOCAL normally had about 3K of code with only 1K left over for user program and data. With a few patches, FOCAL could use a second 4K field for user program and data. Moreover, additional 4K fields could be allocated to separate users, turning 4K FOCAL into a multi-user timesharing system.

Virtualization

On the PDP-8/E and later models, the Memory Extension Controller was enhanced to enable machine virtualization. A program written to use a PDP-8's entire resources can coexist with other such programs on the same PDP-8 under the control of a virtual machine manager. The manager can make all I/O instructions (including those that operated on the Memory Extension Controller) cause a trap (an interrupt handled by the manager). In this way, the manager can map memory references, map data or instruction fields, and redirect I/O to different devices. Each original program has complete access to a "virtual machine" provided by the manager.

New I/O instructions to the Memory Extension Controller retrieve the current value of the data and instruction fields, letting software save and restore most of the machine state across a trap. However, a program can not sense whether the CPU is in the process of deferring the effect of a CIF instruction (whether it has executed a CIF and not yet executed the matching jump instruction). The manager has to include a complete PDP-8 emulator (not difficult for an 8-instruction machine). Whenever a CIF instruction traps to the manager, it has to emulate the instructions up to the next jump. Fortunately, as a jump usually is the next instruction after CIF, this emulation does not slow programs down much, but it is a large workaround to a seemingly small design deficiency.

By the time of the PDP-8/A, memory prices had fallen enough that memory exceeding 32K was desirable. The 8/A added a new set of instructions for handling more than eight fields of memory. The field number could now be placed in the AC, rather than hard-coded into the instruction. However, by this time, the PDP-8 was in decline, so very little standard software was modified to use these new features.


Examples

The following examples show code in PDP-8 assembly language as one might write for the PAL-III assembler.

Comparing two numbers

The following piece of code shows what is needed just to compare two numbers:

        /Compare numbers in memory at OPD1 and OPD2
                CLA CLL     /Must start with 0 in AC and link
                TAD OPD1    /Load first operand into AC (by adding it to 0); link is still clear
                CIA         /Complement, then increment AC, negating it
                TAD OPD2    /AC now has OPD2-OPD1; if OPD2≥OPD1, sum overflows and link is set
                SZL         /Skip if link is clear
                JMP OP2GT   /Jump somewhere in the case that OPD2≥OPD1;
                            /Otherwise, fall through to code below.

As shown, much of the text of a typical PDP-8 program focuses not on the author's intended algorithm but on low-level mechanics. An additional readability problem is that in conditional jumps such as the one shown above, the conditional instruction (which skips around the JMP) highlights the opposite of the condition of interest.

String output

This complete PDP-8 assembly language program outputs "Hello, world!" to the teleprinter.

        *10                   / Set current assembly origin to address 10,
        STPTR,    STRNG-1     / An auto-increment register (one of eight at 10-17)

        *200                  / Set current assembly origin to program text area
        HELLO,  CLA CLL       / Clear AC and Link again (needed when we loop back from tls)
                TAD I Z STPTR / Get next character, indirect via PRE-auto-increment address from the zero page
                SNA           / Skip if non-zero (not end of string)
                HLT           / Else halt on zero (end of string)
                TLS           / Output the character in the AC to the teleprinter
                TSF           / Skip if teleprinter ready for character
                JMP .-1       / Else jump back and try again
                JMP HELLO     / Jump back for the next character

        STRNG,  310           / H
                345           / e
                354           / l
                354           / l
                357           / o
                254           /,
                240           / (space)
                367           / w
                357           / o
                362           / r
                354           / l
                344           / d
                241           / !
                0             / End of string
        $HELLO                /DEFAULT TERMINATOR

Subroutines

The PDP-8 processor does not implement a stack upon which to store registers or other context when a subroutine is called or an interrupt occurs. (A stack can be implemented in software, as demonstrated in the next section.) Instead, the JMS instruction simply stores the updated PC (pointing past JMS, to the return address) at the effective address and jumps to the effective address plus one. The subroutine returned to its caller using an indirect JMP instruction that addresses the subroutine's first word.

For example, here is "Hello, World!" re-written to use a subroutine. When the JMS instruction jumps to the subroutine, it modifies the 0 coded at location OUT1:

        *10                     / Set current assembly origin to address 10,
        STPTR,  STRNG-1         / An auto-increment register (one of eight at 10-17)

        *200                    / Set assembly origin (load address)
        LOOP,   TAD I STPTR     / Pre-increment mem location 10, fetch indirect to get the next character of our message
                SNA             / Skip on non-zero AC
                HLT             / Else halt at end of message
                JMS OUT1        / Write out one character
                JMP LOOP        / And loop back for more
        OUT1,   0               / Will be replaced by caller's updated PC
                TSF             / Skip if printer ready
                JMP .-1         / Wait for flag
                TLS             / Send the character in the AC
                CLA CLL         / Clear AC and Link for next pass
                JMP I OUT1      / Return to caller
        STRNG, "H               / A well-known message
               "e               /
               "l               / NOTE:
               "l               /
               "o               /   Strings in PAL-8 and PAL-III were "sixbit"
               ",               /   To use ASCII, we spell it out, character by character
               "                /
               "w               /
               "o               /
               "r               /
               "l               /
               "d               /
               "!               /
               015              /
               012              /
               0                / Mark the end of our null-terminated string (.ASCIZ hadn't been invented yet!)

The fact that the JMS instruction uses the word just before the code of the subroutine to deposit the return address prevents reentrancy and recursion without additional work by the programmer. It also makes it difficult to use ROM with the PDP-8 because read-write return-address storage is commingled with read-only code storage in the address space. Programs intended to be placed into ROMs approach this problem in several ways:

-   They copy themselves to read-write memory before execution, or
-   They are placed into special ROM cards that provide a few words of read/write memory, accessed indirectly through the use of a thirteenth flag bit in each ROM word.
-   They avoid the use of subroutines; or use code such as the following, instead of the JMS instruction, to put the return address in read-write memory:

        JUMPL, DCA TEMP         / Deposit the accumulator in some temporary location
               TAD JUMPL+3      / Load the return address into the accumulator: hard coded
               JMP SUBRO        / Go to the subroutine, and have it handle jumping back (to JUMPL+3)

The use of the JMS instruction makes debugging difficult. If a programmer makes the mistake of having a subroutine call itself, directly or by an intermediate subroutine, then the return address for the outer call is destroyed by the return address of the subsequent call, leading to an infinite loop. If one module is coded with an incorrect or obsolete address for a subroutine, it would not just fail to execute the entire code sequence of the subroutine, it might modify a word of the subroutine's code, depositing a return address that the processor might interpret as an instruction during a subsequent correct call to the subroutine. Both types of error might become evident during the execution of code that was written correctly.

Software stack

Though the PDP-8 does not have a hardware stack, stacks can be implemented in software.[33] Here are example PUSH and POP subroutines, simplified to omit issues such as testing for stack overflow and underflow:

        PUSH, 0
              DCA DATA
              CLA CMA     / -1
              TAD SP
              DCA SP
              TAD DATA
              DCA I SP
              JMP I PUSH     /Return

        POP,  0
              CLA CLL
              TAD I SP
              ISZ SP
              JMP I POP

        DATA, 0
        SP, 0

And here is "Hello World" with this "stack" implemented, and "OUT" subroutine:

        *200
        MAIN,  CLA CLL         /Set the message pointer
               TAD (MESSG      /To the beginning of the message (literal)
               DCA SP

        LOOP,  JMS POP
               SNA             /Stop execution if zero
               HLT
               JMS OUT         /Otherwise, output a character
               JMP LOOP

        MESSG, "H
               "e
               "l
               "l
               "o
               ",
               "
               "w
               "o
               "r
               "l
               "d
               "!
               015
               012
               0

        OUT,    0               / Will be replaced by caller's updated PC
                TSF             / Skip if printer ready
                JMP .-1         / Wait for flag
                TLS             / Send the character in the AC
                CLA CLL         / Clear AC and Link for next pass
                JMP I OUT       / Return to caller

Linked list

Another possible subroutine for the PDP-8 is a linked list.

         GETN, 0     /Gets the number pointed to and moves the pointer
         CLA CLL     /Clear accumulator
         TAD I PTR   /Gets the number pointed to
         DCA TEMP    /Save current value
         ISZ PTR     /Increment pointer
         TAD I PTR   /Get next address
         DCA PTR     /Put in pointer
         JMP I GETN  /return
         PTR,  0
         TEMP, 0


Interrupts

There is a single interrupt line on the PDP-8 I/O bus. The processor handles any interrupt by disabling further interrupts and executing a JMS to location 0000. As it is difficult to write reentrant subroutines, it is difficult to nest interrupts and this is usually not done; each interrupt runs to completion and re-enables interrupts just before executing the JMP I 0 instruction that returns from the interrupt.

Because there is only a single interrupt line on the I/O bus, the occurrence of an interrupt does not inform the processor of the source of the interrupt. Instead, the interrupt service routine has to serially poll each active I/O device to see if it is the source. The code that does this is called a _skip chain_ because it consists of a series of PDP-8 "test and skip if flag set" I/O instructions. (It was not unheard-of for a skip chain to reach its end without finding ANY device in need of service.) The relative interrupt priority of the I/O devices is determined by their position in the skip chain: If several devices interrupt, the device tested earlier in the skip chain is serviced first.


Books

An engineering textbook popular in the 1980s, _The Art of Digital Design_ by David Winkel and Franklin Prosser, contains an example problem spanning several chapters in which the authors demonstrate the process of designing a computer that is compatible with the PDP-8/I. The function of every component is explained. Although it is not a production design, as it uses more modern SSI and MSI components, the exercise provides a detailed description of the computer's operation.


References

-   C. Gordon Bell and Allen Newell, 1971, _Computer Structures: Readings and Examples_, McGraw-Hill Book Company, New York. Chapter 5 _The DEC PDP-8_, pages 120-136. With enough detail that an electrical engineer could build one (if able to find the parts).


External links

-   pdp-8 Documentation: The Small Computer Handbook (1966 Edition), Sections 1 and 2 and others are available from Simon Fraser University
-   -   http://homepage.cs.uiowa.edu/~jones/pdp8/
-   -   pdp8online.com has a running PDP8 that anyone can control through a Java applet, plus a webcam to show the results.
-   dpa, a portable PDP-8 cross-assembler
-   Spare Time Gizmos' SBC6120 PDP-8 compatible computer with optional front panel
-   Still working Classic 8, PDP 8e and 8i in a German computer museum
-   Bernhard Baehr's slick PDP-8/E Simulator for Macintosh
-   Willem van der Mark's PDP-8/E Simulator in Java
-   http://simh.trailing-edge.com a very portable simulator for PDP-8, that works on virtually any modern OS.
-   PiDP-8 open-source replica of the PDP-8 using a Raspberry Pi running SIMH attached to a PDP-8 front panel replica.
-   The Digital Equipment Corporation PDP-8, 1965Computer History Collection from the Smithsonian
-   Historic application of PDP8 in Germany for all Deutsche Bank centers and other financial institutes: Olympia Multiplex 80 (Olympia Business Systems)
-   A guide to the preservation and restoration of PDP-8 computers
-   Digital Equipment Corporation's PDP-8 Steve Gibson's explanation on how the PDP-8 works and how to program it.
-   YouTube has a video series showing the PDP-8.
-

Category:DEC hardware Category:Minicomputers Category:Transistorized computers Category:Instruction set architectures Category:12-bit computers Category:Computer-related introductions in 1965

[1]

[2]

[3] Marshall William McMurran, _Achieving Accuracy: A Legacy of Computers and Missiles_ Xlibris Corporation, 2009, , p. 88.

[4]

[5]

[6]

[7]

[8] The Rhode Island Computer Museum. "Digital Equipment PDP-8/S, S/N 517".

[9]

[10]

[11]

[12]

[13] a phrase used in Section 1.1 of "Introduction to the Central Processing Unit (CPU)" of a 2007 document about a Texas Instruments microcomputer.

[14]

[15]

[16]

[17]

[18]

[19] C. Gordon Bell, et al.; Computer Structures, Principles and Organization, 1982, PDP-8 chapter

[20]

[21]

[22]

[23]

[24]

[25]

[26]

[27]

[28]

[29]

[30]

[31]

[32]

[33] Mark Smotherman. "DEC PDP-8 Subroutines". 2002.