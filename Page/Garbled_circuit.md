GARBLED CIRCUIT is a cryptographic protocol that enables two-party secure computation in which two mistrusting parties can jointly evaluate a function over their private inputs without the presence of a trusted third party. In the garbled circuit protocol, the function has to be described as a Boolean circuit.

The history of garbled circuits is complicated. The invention of garbled circuit was credited to Yao, as Yao introduced the idea in the oral presentation of his paper[1] in FOCS'86. This was documented by Oded Goldreich in[2] in 2003. The first written document about this technique was by Goldreich, Micali, and Wigderson in STOC'87.[3] The garbled circuit was first termed by Beaver, Micali, and Rogaway in STOC'90.[4] Yao's protocol solving the Yao's Millionaires' Problem was the beginning example of secure computation, yet it is not directly related to garbled circuits.


Background

Oblivious transfer

In the garbled circuit protocol, we make use of oblivious transfer. In the oblivious transfer, a string is transferred between a sender and a receiver in the following way: a sender has two strings S₀ and S₁. The receiver chooses i ∈ {0, 1} and the sender sends S_(i) with the oblivious transfer protocol such that

1.  the receiver doesn't get any information about S_((1 − i)),
2.  the value of i is not exposed to the sender.

The oblivious transfer can be built using asymmetric cryptography like the RSA cryptosystem.

Definitions and notations

Operator ∥ is string concatenation. Operator ⊕ is bit-wise XOR. k is security parameter and the length of keys. It should be greater than 80 and is usually set at 128.


Garbled circuit protocol

The protocol consists of 6 steps as follows:

1.  The underlying function (e.g., in the millionaires' problem, comparison function) is described as a Boolean circuit with 2-input gates. The circuit is known to both parties. This step can be done beforehand by a third-party.
2.  Alice _garbles_ (encrypts) the circuit. We call Alice the _garbler_.
3.  Alice sends the _garbled circuit_ to Bob along with her encrypted input.
4.  Bob through oblivious transfer receives his encrypted inputs from Alice. In terms of the definition from above, Bob is the receiver and Alice the sender at this oblivious transfer.
5.  Bob _evaluates_ (decrypts) the circuit and obtains the encrypted outputs. We call Bob the _evaluator_.
6.  Alice and Bob communicate to learn the output.

Circuit generation

The Boolean circuit for small functions can be generated by hand. It is conventional to make the circuit out of 2-input XOR and AND gates. It is important that the generated circuit has the minimum number of AND gates (see Free XOR optimization). There are methods that generate the optimized circuit in term of number of AND gates using logic synthesis technique.[5] The circuit for the Millionaires' Problem is a digital comparator circuit (which is a chain of full adder work as a subtractor and outputs the carry flag). The circuit of full adder can be implemented using only one AND gate and some XOR gates. This means the total number of AND gates for the circuit of the Millionaires' Problem is equal to the bit-width of inputs.

Garbling

Garbled_circuit_AND_gate_illustration.svg Garbled_circuit_AND_gate_truth_table_illustration.svg Alice (garbler) encrypts the Boolean circuit in this step to obtain a _garbled circuit_. Alice assigns two randomly generated strings called _labels_ to each wire in the circuit: one for Boolean semantic 0 and one for 1. (The label is k-bit long where k the security parameter and is usually set to 128.) Next, She goes to all the gates in the circuit and replace 0 and 1 in the truth tables with the corresponding labels. The table below shows the truth table for an AND gate with two inputs: w^(a), w^(b) and output w^(c):

  a   b   c
  --- --- ---
  0   0   0
  0   1   0
  1   0   0
  1   1   1

Alice replaced 0 and 1 with the corresponding labels:

  a        b        c
  -------- -------- --------
  X₀^(a)   X₀^(b)   X₀^(c)
  X₀^(a)   X₁^(b)   X₀^(c)
  X₁^(a)   X₀^(b)   X₀^(c)
  X₁^(a)   X₁^(b)   X₁^(c)

She then encrypts the output entry of the truth table with the corresponding two input labels. The encrypted table is called garbled table. This is done such that one can decrypt the garbled table only if he has the correct two input labels. In the table below, Enc_(k)(X) is a double-key symmetric encryption in which k is the secret key and X is the value to be encrypted (see Fixed-Key Blockcipher).

  Garbled Table
  ------------------------------
  Enc_(X₀^(a), X₀^(b))(X₀^(c))
  Enc_(X₀^(a), X₁^(b))(X₀^(c))
  Enc_(X₁^(a), X₀^(b))(X₀^(c))
  Enc_(X₁^(a), X₁^(b))(X₁^(c))

After this, Alice randomly permutes the table such that the output value cannot be determined from the row. The protocol's name, GARBLED, is derived from this random permutation.

Data transfer

Alice sends the computed garbled tables for all gates in the circuit to Bob. Bob needs input labels to open the garbled tables. Thus, Alice chooses the labels corresponding to her input a to Bob. For example, if Alice's input is A = a₄a₃a₂a₁a₀ = 01101, then she sends X₀^(a₄), X₁^(a₃), X₁^(a₂), X₀^(a₁), and X₁^(a₀) to Bob. Bob will not learn anything about Alice's input, A, since the labels are randomly generated by Alice and they look like random strings to Bob.

Bob needs the labels corresponding to his input as well. He receives his labels through oblivious transfers for each bit of his input. For example, if Bob's input is B = b₄b₃b₂b₁b₀ = 10100, Bob first asks for b₀ = 0 between Alice's labels X₀^(b₀) and X₁^(b₀). Through a 1-out-of-2 oblivious transfer, he receives X₀^(b₀) and so on. After the oblivious transfers, Alice will not learn anything about Bob's input and Bob will not learn anything about the other labels.

Evaluation

After the data transfer, Bob has the garbled tables and the input labels. He goes through all gates one by one and tries to decrypt the rows in their garbled tables. He is able to open one row for each table and retrieve the corresponding output label: X^(c) = Dec_(X^(a), X^(b))(garbled_table[i]), where 0 ≤ i < 3. He continues the evaluation until he reaches to the output labels.

Revealing output

After the evaluation, Bob obtains the output label, X^(c), and Alice knows its mapping to Boolean value since she has both labels: X₀^(c) and X₁^(c). Either Alice can share her information to Bob or Bob can reveal the output to Alice such that one or both of them learn the output.


Optimization

Point-and-permute

In this optimization, Alice generates a random bit, s, called select bit for each wire w^(a). She then sets the first bit of label 0, X₀^(a) to s and the first bit of label 1, X₁^(a), to s̄ (NOT of s). She then, instead of randomly permuting, sorts the garbled table according to the inputs select bit. This way, Bob does not need to test all four rows of the table to find the correct one, since he has the input labels and can find the correct row and decrypt it with one attempt. This reduces the evaluation load by 4 times. It also does not reveal anything about the output value because the select bits are randomly generated.[6]

Row reduction

This optimization reduces the size of garbled tables from 4 rows to 3 rows. Here, instead of generating a label for the output wire of a gate randomly, Alice generates it using a function of the input labels. She generates the output labels such that the first entry of the garbled table becomes all 0 and no longer needs to be sent:[7]

$\begin{align}
&Enc_{X_0^a, X_0^b}(X_0^c) = 0 \\
&X_0^c = Dec_{X_0^a, X_0^b}(0).
\end{align}$

Free XOR

In this optimization, Alice generates a global random (k-1)-bit value R which is just known to her. During garbling for any wire w^(a), she only generates a label X₀^(a) and computes the other label X₁^(a) as X₁^(a) = X₀^(a) ⊕ (R ∥ 1). With this convention, the label for the output wire of the XOR gates with input wires w^(a), w^(b) and output wire w^(c) can be simply computed as X^(c) = X^(a) ⊕ X^(b). The proof of security for this optimization is given in the Free-XOR paper.[8]

Implication

Free XOR optimization implies an important point that the amount of data transfer (communication) and number of encryption and decryption (computation) of the garbled circuit protocol relies only on the number of AND gates in the Boolean circuit not the XOR gates. Thus, between two Boolean circuits representing the same function, the one with the smaller number of AND gates is preferred.

Fixed-key blockcipher

This method allows to efficiently garble and evaluate AND gates using fixed-key AES, instead of costly cryptographic hash function like SHA-2. In this garbling scheme which is compatible with the Free XOR and Row Reduction techniques, the output key X^(c) is encrypted with the input token X^(a) and X^(b) using the encryption function Enc(X^(a), X^(b), T, X^(c)) = π(K) ⊕ K ⊕ X^(c), where K = 2X^(a) ⊕ 4X^(b) ⊕ T, π is a fixed-key block cipher (e.g., instantiated with AES), and T is a unique-per-gate number (e.g., gate identifier) called _tweak_.[9]

Half And

This optimization reduce the size of garbled table for AND gates from 3 row in Row Reduction to 2 rows. It is shown that this is the theoretical minimum for the number of rows in the garbled table, for a certain class of garbling techniques.[10]


See also

-   Cryptography
-   RSA
-   Secure multi-party computation
-   Yao's Millionaires' Problem


References


Further reading

-

Category:Theory of cryptography Category:Cryptographic protocols

[1]

[2]

[3]

[4]

[5]

[6]

[7]

[8]

[9]

[10]