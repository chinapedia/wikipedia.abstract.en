In formal language theory, a CONTEXT-FREE LANGUAGE (CFL) is a language generated by a context-free grammar (CFG).

Context-free languages have many applications in programming languages, in particular, most arithmetic expressions are generated by context-free grammars.


Background

Context-free grammar

Different context-free grammars can generate the same context-free language. Intrinsic properties of the language can be distinguished from extrinsic properties of a particular grammar by comparing multiple grammars that describe the language.

Automata

The set of all context-free languages is identical to the set of languages accepted by pushdown automata, which makes these languages amenable to parsing. Further, for a given CFG, there is a direct way to produce a pushdown automaton for the grammar (and thereby the corresponding language), though going the other way (producing a grammar given an automaton) is not as direct.


Examples

A model context-free language is L = {a^(n)b^(n) : n ≥ 1}, the language of all non-empty even-length strings, the entire first halves of which are 's, and the entire second halves of which are 's. is generated by the grammar S → aSb | ab. This language is not regular. It is accepted by the pushdown automaton M = ({q₀, q₁, q_(f)}, {a, b}, {a, z}, δ, q₀, z, {q_(f)}) where δ is defined as follows:[1]

$$\begin{align}
\delta(q_0, a, z) &= (q_0, az) \\
\delta(q_0, a, a) &= (q_0, aa) \\
\delta(q_0, b, a) &= (q_1, \varepsilon) \\
\delta(q_1, b, a) &= (q_1, \varepsilon) \\
\delta(q_1, \varepsilon, z) &= (q_f, \varepsilon)
\end{align}$$

Unambiguous CFLs are a proper subset of all CFLs: there are inherently ambiguous CFLs. An example of an inherently ambiguous CFL is the union of {a^(n)b^(m)c^(m)d^(n)|n, m > 0} with {a^(n)b^(n)c^(m)d^(m)|n, m > 0}. This set is context-free, since the union of two context-free languages is always context-free. But there is no way to unambiguously parse strings in the (non-context-free) subset {a^(n)b^(n)c^(n)d^(n)|n > 0} which is the intersection of these two languages.

Dyck language

The language of all properly matched parentheses is generated by the grammar S → SS | (S) | ε.


Properties

Context-free parsing

The context-free nature of the language makes it simple to parse with a pushdown automaton.

Determining an instance of the membership problem; i.e. given a string w, determine whether w ∈ L(G) where L is the language generated by a given grammar G; is also known as _recognition_. Context-free recognition for Chomsky normal form grammars was shown by Leslie G. Valiant to be reducible to boolean matrix multiplication, thus inheriting its complexity upper bound of _O_(_n_^(2.3728639)).[2][3][4] Conversely, Lillian Lee has shown _O_(_n_^(3−ε)) boolean matrix multiplication to be reducible to _O_(_n_^(3−3ε)) CFG parsing, thus establishing some kind of lower bound for the latter.[5]

Practical uses of context-free languages require also to produce a derivation tree that exhibits the structure that the grammar associates with the given string. The process of producing this tree is called _parsing_. Known parsers have a time complexity that is cubic in the size of the string that is parsed.

Formally, the set of all context-free languages is identical to the set of languages accepted by pushdown automata (PDA). Parser algorithms for context-free languages include the CYK algorithm and Earley's Algorithm.

A special subclass of context-free languages are the deterministic context-free languages which are defined as the set of languages accepted by a deterministic pushdown automaton and can be parsed by a LR(k) parser.[6]

See also parsing expression grammar as an alternative approach to grammar and parser.

Closure

Context-free languages are closed under the following operations. That is, if _L_ and _P_ are context-free languages, the following languages are context-free as well:

-   the union L ∪ P of _L_ and _P_
-   the reversal of _L_
-   the concatenation L ⋅ P of _L_ and _P_
-   the Kleene star L^(*) of _L_
-   the image φ(L) of _L_ under a homomorphism φ
-   the image φ^( − 1)(L) of _L_ under an inverse homomorphism φ^( − 1)
-   the circular shift of _L_ (the language {vu : uv ∈ L})
-   the prefix closure of _L_ (the set of all prefixes of strings from _L_)
-   the quotient _L_/_R_ of _L_ by a regular language _R_

Nonclosure under intersection, complement, and difference

The context-free languages are not closed under intersection. This can be seen by taking the languages A = {a^(n)b^(n)c^(m) ∣ m, n ≥ 0} and B = {a^(m)b^(n)c^(n) ∣ m, n ≥ 0}, which are both context-free.[7] Their intersection is A ∩ B = {a^(n)b^(n)c^(n) ∣ n ≥ 0}, which can be shown to be non-context-free by the pumping lemma for context-free languages. As a consequence, context-free languages cannot be closed under complementation, as for any languages _A_ and _B_, their intersection can be expressed by union and complement: $A \cap B = \overline{\overline{A} \cup \overline{B}}$. In particular, context-free language cannot be closed under difference, since complement can be expressed by difference: $\overline{L} = \Sigma^* \setminus L$.[8]

However, if _L_ is a context-free language and _D_ is a regular language then both their intersection L ∩ D and their difference L \ D are context-free languages.

Decidability

In formal language theory, questions about regular languages are usually decidable, but ones about context-free languages are often not. It is decidable whether such a language is finite, but not whether it contains every possible string, is regular, is unambiguous, or is equivalent to a language with a different grammar.[9]

The following problems are undecidable for arbitrarily given context-free grammars A and B:

-   Equivalence: is L(A) = L(B)?
-   Disjointness: is L(A) ∩ L(B) = ∅ ? However, the intersection of a context-free language and a _regular_ language is context-free,[10] hence the variant of the problem where _B_ is a regular grammar is decidable (see "Emptiness" below).
-   Containment: is L(A) ⊆ L(B) ? Again, the variant of the problem where _B_ is a regular grammar is decidable, while that where _A_ is regular is generally not.
-   Universality: is L(A) = Σ^(*) ?

The following problems are _decidable_ for arbitrary context-free languages:

-   Emptiness: Given a context-free grammar _A_, is L(A) = ∅ ?
-   Finiteness: Given a context-free grammar _A_, is L(A) finite?
-   Membership: Given a context-free grammar _G_, and a word w, does w ∈ L(G) ? Efficient polynomial-time algorithms for the membership problem are the CYK algorithm and Earley's Algorithm.

According to Hopcroft, Motwani, Ullman (2003),[11] many of the fundamental closure and (un)decidability properties of context-free languages were shown in the 1961 paper of Bar-Hillel, Perles, and Shamir[12]

Languages that are not context-free

The set {a^(n)b^(n)c^(n)d^(n)|n > 0} is a context-sensitive language, but there does not exist a context-free grammar generating this language. So there exist context-sensitive languages which are not context-free. To prove that a given language is not context-free, one may employ the pumping lemma for context-free languages[13] or a number of other methods, such as Ogden's lemma or Parikh's theorem.[14]


Notes


References

-   -   -   -   Chapter 2: Context-Free Languages, pp. 91–122.

-   Jean-Michel Autebert, Jean Berstel, Luc Boasson, Context-Free Languages and Push-Down Automata, in: G. Rozenberg, A. Salomaa (eds.), Handbook of Formal Languages, Vol. 1, Springer-Verlag, 1997, 111-174.

Category:Formal languages Category:Languages Category:Linguistics

[1] meaning of δ's arguments and results: δ(state₁, read, pop) = (state₂, push)

[2]

[3]

[4] In Valiant's papers, _O_(_n_^(2.81)) given, the then best known upper bound. See Matrix multiplication#Algorithms for efficient matrix multiplication and Coppersmith–Winograd algorithm for bound improvements since then.

[5]

[6]

[7] A context-free grammar for the language _A_ is given by the following production rules, taking _S_ as the start symbol: _S_ → _Sc_ | _aTb_ | _ε_; _T_ → _aTb_ | _ε_. The grammar for _B_ is analogous.

[8]

[9]

[10] , p. 59, Theorem 6.7

[11]  Here: Sect.7.6, p.304, and Sect.9.7, p.411

[12]

[13]

[14] How to prove that a language is not context-free?